# Self-Reflection – Problem Set 0

**Course:** MIT 6.0001 (OCW, Fall 2016)  
**Assignment:** Problem Set 0  
**Date:** 2025-10-25  
**Author:** Zach McFatridge  

# Reflection — Problem Set #1
**Course:** 6.0001 – Introduction to Computer Science

**Date Completed:** 2025-10-25

---

## 1. Objective
Briefly describe what the assignment was *meant* to teach or test.
> Example: “This problem set was designed to strengthen understanding of recursion and complexity trade-offs through algorithmic problem solving.”

---

## 2. Process & Reasoning
Explain how you approached the problem conceptually and technically.
- What strategies or heuristics did you use?  
- What decisions or assumptions guided your design?  
- What alternative approaches did you consider (and why didn’t you use them)?  

> Example: “I started with an iterative approach to check correctness, then refactored into a recursive solution to explore divide-and-conquer structure…”

---

## 3. Key Insights
List 2–3 things you *realized* that you didn’t know before.
- Conceptual insight (e.g., “Recursion is not about loops but about *state*.”)  
- Technical or syntax insight  
- Cognitive/meta insight (“I notice I tend to overcomplicate before verifying edge cases.”)

---

## 4. Challenges & Debugging
Describe what confused you or what broke.
- How did you diagnose the issue?  
- What helped you resolve it?  
- If still unresolved, what are your hypotheses?

> Example: “My binary search returned off-by-one errors; visualizing the index updates helped isolate the mid-point logic.”

---

## 5. Connection to Broader Learning
Tie this assignment to:
- Earlier material (e.g., connections to discrete math or earlier code patterns)  
- Other domains (e.g., psychology, cognition, philosophy, etc.)  
- Real-world analogies or relevance  

> Example: “The concept of recursion mirrors self-referential processes in cognition — smaller units solving subproblems that build to an integrated whole.”

---

## 6. Next Steps
What’s your plan for reinforcement or extension?
- What will you practice or research next?  
- Do you plan to generalize this solution, visualize it, or document it further?

> Example: “I’ll rewrite the recursive solution iteratively to compare performance and clarity.”

---

## 7. Freeform Summary 
As mentioned in [the parent file](https://github.com/nescient-18/mit-6.0001-intro-cs/blob/main/AI_DISCLOSURE.md), I had done this assignment before several years ago. It was elementary at this point. My intention going back to this assignment was to make my approach robust and professional. I'm presently unfamiliar with more rigorous programming and software development, so I wanted to approach this with the mindset of getting out as much as possible from a basic assignment.

Initially, I had an input check within the main body of the program that was very similar to `get_float()`. (Side Note: I should be more incremental with my commits and pushes so my progress appears as a genuine learning process.) After sending that code to GPT, it recommended to make a function to take care of that. Duh.

It recommended to have a more general key function check -- something I could put in a `lambda` function, say -- but I didn't feel it necessary for this assignment since it was a simple binary conditon: positive or not.

### One Sentence Summary
> “This assignment deepened my understanding of X by forcing me to grapple with Y, revealing Z.”
---

## Optional: Technical Addendum
If relevant:
- Runtime complexity:  
- Memory complexity:  
- Libraries used:  
- Known limitations:  
- Test coverage summary:
